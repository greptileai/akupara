#!/usr/bin/env bash
# Generate Hatchet client token for Greptile authentication
# Usage: generate-hatchet-token.sh
#
# This script:
#   1. Waits for Hatchet services to be healthy
#   2. Generates a new token via hatchet-admin CLI
#   3. Writes token to .env.hatchet-generated (env file format for docker-compose)
#   4. Creates sentinel file .hatchet-token-ready
#
# Exit codes:
#   0 - Token generated or already exists
#   1 - Error generating token

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${SCRIPT_DIR}/.."
ENV_FILE="${PROJECT_DIR}/.env"
SENTINEL_FILE="${PROJECT_DIR}/.hatchet-token-ready"
TOKEN_FILE="${PROJECT_DIR}/.env.hatchet-generated"  # env file format: HATCHET_CLIENT_TOKEN=xxx

TENANT_ID_DEFAULT="707d0855-80ab-4e1f-a156-f1c4546cbf52"
TOKEN_NAME="auto-generated-by-greptile"
TOKEN_TTL="876000h"  # ~100 years
MAX_WAIT=120

log() {
  echo "[generate-hatchet-token] $1"
}

# Get value from .env file
get_env_value() {
  local key="$1"
  local value
  value=$(awk -F'=' -v k="$key" '
    $1==k {
      $1=""; sub(/^=/, ""); print $0
    }
  ' "$ENV_FILE" | head -n1)
  # Strip quotes and carriage returns
  value="${value%%$'\r'}"
  value="${value%%\"}"
  value="${value##\"}"
  value="${value%%\'}"
  value="${value##\'}"
  echo "$value"
}

current_token() {
  # Check token file first (new approach), fall back to .env (legacy)
  if [[ -f "$TOKEN_FILE" ]]; then
    grep -E '^HATCHET_CLIENT_TOKEN=' "$TOKEN_FILE" 2>/dev/null | cut -d'=' -f2- | tr -d "'\""
  else
    get_env_value "HATCHET_CLIENT_TOKEN"
  fi
}

# Validate .env exists
if [[ ! -f "$ENV_FILE" ]]; then
  log "ERROR: Missing $ENV_FILE"
  exit 1
fi

# Get tenant ID from env or use default
tenant_id=$(get_env_value "HATCHET_TENANT_ID")
if [[ -z "$tenant_id" ]]; then
  tenant_id="$TENANT_ID_DEFAULT"
fi

# Check if token already exists
if [[ -f "$SENTINEL_FILE" && -n "$(current_token)" ]]; then
  log "Hatchet token already generated; skipping"
  exit 0
fi

log "Ensuring Hatchet services are healthy before generating token"

# Wait for required Hatchet services using wait-for-service.sh
"${SCRIPT_DIR}/wait-for-service.sh" hatchet-rabbitmq "$MAX_WAIT" --profile hatchet
"${SCRIPT_DIR}/wait-for-service.sh" hatchet-api "$MAX_WAIT" --profile hatchet
"${SCRIPT_DIR}/wait-for-service.sh" hatchet-engine "$MAX_WAIT" --profile hatchet

log "Generating Hatchet token for tenant $tenant_id"

# Generate token via hatchet-admin CLI
set +o pipefail
# Capture output and filter out log messages, keeping only the JWT token
# Filter out warning messages about JWT_SECRET and LLM_PROXY_KEY (not needed for hatchet token generation)
raw_output=$(docker compose --profile hatchet --project-directory "$PROJECT_DIR" run --rm --no-deps hatchet-setup-config \
  /hatchet/hatchet-admin token create \
  --config /hatchet/config \
  --tenant-id "$tenant_id" \
  --name "$TOKEN_NAME" \
  --expiresIn "$TOKEN_TTL" 2>&1 | \
  grep -v -E '(level=warning|level=info|JWT_SECRET|LLM_PROXY_KEY|cleaning up|time=)' | \
  tr -d '\r')
status=$?
set -o pipefail

# Extract only the JWT token (starts with "eyJ") and filter out any remaining log messages
new_token=$(echo "$raw_output" | grep -E '^eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+' | head -n1 | tr -d '[:space:]')

if [[ $status -ne 0 || -z "$new_token" ]]; then
  log "ERROR: Failed to generate Hatchet token"
  log "Raw output: $raw_output"
  exit 1
fi

log "Writing token to $TOKEN_FILE"

# Write token in env file format (used by docker-compose env_file directive)
cat > "$TOKEN_FILE" << EOF
# Auto-generated by Greptile - do not edit
# This file is loaded by docker-compose as an additional env_file
HATCHET_CLIENT_TOKEN=${new_token}
EOF
chmod 640 "$TOKEN_FILE" 2>/dev/null || true

# Create sentinel file to indicate token is ready
touch "$SENTINEL_FILE"
chmod 640 "$SENTINEL_FILE" 2>/dev/null || true

log "Hatchet token generated successfully"

# If running under systemd and greptile-app.service exists, trigger it
if command -v systemctl &>/dev/null && systemctl list-unit-files 2>/dev/null | grep -q '^greptile-app.service'; then
  log "Triggering greptile-app.service start"
  systemctl start greptile-app.service || true
fi
